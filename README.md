# gaussian-free-fields-reu
**Decription of overall code here**

## driver.cpp

---
**Description of what is going on.**

    double getMeans(double s, int n, int numTrials){
    
    

## RandVec

---
**Description of what is going on.**

    Private:
      vector<distribution>;                             // comment here
      int len;                                          // gives the length of random sequences generated by this object
      default_random_engine generator;                  //
      unsigned generate_seed();                         // used to generate a seed to ensure independence for multithreaded sampling
    Public:
      vector<vector<double>> parallelSampler();         // creates an array of independent gaussian random variables
      vector<double> sample();                          // samples a vector of standard normal of length n

## RandArr

---
**Description of what is going on.**

    Private:
      int dimArray;
      int numTrials;
      vector<vector<vector<double>>> samples;
      void threadSafe_Sample();
      void sample_univariate_gaussian(unsigned int seed, int index1, int index2);
    Public:
      RandArr array(int maxDim, int numTrials);
      RandArr()=default;
      ~RandArr;
      vector<vector<vector<double>>> getSample(int size);

## DFGF (Abstract)

---
**Description of what is going on.**

    Private:
        int n;                                          // degree of DFGF
        double s;                                       // parameter of DFGF
        int numTrials;                                  // number of trals to be ran
        vector<double> maxSamples;                      //
    Public:
        virtual void sample();                          //
        virtual double computeMax();                    //
        virtual double computEmpMean();                 //

## DFGF_S1

---
**Description of what is going on**

    Private:
        vector<double> domain;                          // comment here
        vector<double> eigVals;                         // computes the vector of eigen values associated with the field of degree n
        vector<vector<double>> coeffs;                  // computes the coefficients for evaluating the fields
        RandVec gaussianVector;                         // a random vector that will be sampled
        vector<vector<double>> gaussSamples;            // an n by trials array of standard normal gaussian random variables
        vector<vector<double>> eigenFuncs;              // array of eigen vectors
        vector<double> computeFullEigenVector(int r)    // 
        vector<double> computeFullEigenFunction(int r)  //
    Public:
        DFGF_S1(n,s,randVec, numTrials);                // constructor
        DFGF_S1();                                      //
        double evaluatePoint(int k);                    // evaluates a point of the dfgf
        vector<double> evaluate();                      // evaluates the whole field
        vector<vector<double>> runTrials();             // runs the trials using multi threading
        double getMax;                                  // gets the maxima of each resulting thread and pushes it back to the maxima vector
        double emperialMean();                          // returns the means
        
## DFGF_T2

---
**Description of what is going on**

    Private:
        int n;
        double s;
        vector<vector<double>> eigenVals;
        vector<vector<vector<vector<double>>> eigenVectors;
        vector<vector<vector<vector<double>>> coefficients;
        RandArr gaussianArray;
        vector<vector<vector<double>>> trialData;
        vector<double> maxima;
        double meanOfMaxima;
        double computeEigenVal(int p, int q);
        void computeEigenVectors();
        void computeCoeffs();
        void computeMaxVectors();
        
    Public:
        DFGF_T2 (double sVals, int nVales, int numberTrials, RandArr randomArray);
        DFGF_T2=default;
        ~DFGF_T2;
        vector<vector<double>> getEigenVals;
        double compute eigenFunctionPoint(int p, int q, int j, int k);
        vector<vector<double>> computeEigenFunctionVector(int p, int q);
        vector<vector<vector<vector<double>>> getEigenVector();
        double compute eigenCoefficientPoint(int p, int q, int j, int k);
        vector<vector<double>> computeCoefficientVector(int p, int q);
        vector<vector<vector<vector<double>>> getCoefficients();
        double evaluatePoint(int j, int k, vector<vector<double>> sampleVector);
        vector<vector<double>> evaluate(vector<vector<double>> sampleVector);
        void computeEigenVals();
        void runTrials();
        double computeEmpMean();
        double getEmpMean();
        double compute eigenFunctionPoint(int p, int q, int j, int k);
        vector<vector<double>> computeEigenFunctionVector(int p, int q);
        vector<vector<vector<double>>> debugRunTrials(vector<vector<vector<double>>> testRandomArrs);

### Naming Conventions

---
- camelCase
- Abbreviations lowercase
- Classes capitalized


#### Data Files
In order to keep the output data organized use the following convention.
(Month)(Day).StartVal.EndVal.NumberofPoints.NumberofTrials.TimetoComputeN.csv

For example, data generated on July 2nd, starting at 50 and ending at 1000, with 190 points, and 1500 trials per point would take the form
702.50.1000.190.1500.csv
